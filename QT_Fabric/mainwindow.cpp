#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "detect_indent_fft.h"
#include "detect_mura_defects_blur.h"
#include "textspeech.h"
#include <iostream>
#include <QFileDialog>
#include "camerathread.h"
//#include <QTextToSpeech>

using namespace std;
Hlong winID = -1;
std::string way_num = "fft";
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    //TextSpeech speech;
    //speech.initSpeech();
    ui->setupUi(this);
    //参数初始化
    hv_Threshold = ui->threshold->text().toDouble();
    hv_Sigma1 = ui->sigma1->text().toDouble();
    hv_Sigma2 = ui->sigma2->text().toDouble();
    hv_NumImages = 14;
    hv_d_Min = 255;
    hv_d_Max = 1;
    hv_m_Max = HTuple();

    ui->VolumeSlider->setMinimum(0);  // 最小值
    ui->VolumeSlider->setMaximum(99);  // 最大值
    ui->VolumeSlider->setSingleStep(1);

    //设置滑动条控件的值
    ui->VolumeSlider->setValue(30);
    int pos = ui->VolumeSlider->value();
    QString str = QString("%1").arg(pos);
    ui->voicevalue->setText(str);

    //从硬盘读取分类器
    ReadClassGmm("D:/GMMmodel/detection.gmm",
        &hv_GMMHandle);
    //p = new QProcess();
    //p->start("./debug/QT_Fabric.exe");
    //创建线程以及指定文件路径
    myCThread = new cameraThread;
    myCThread->ConfigPath = "D:/config/config0693.xml";
    myCThread->pid = 1;
    myCThread2 = new cameraThread;
    myCThread2->ConfigPath = "D:/config/config0814.xml";
    myCThread2->pid = 2;
    myCThread3 = new cameraThread;
    myCThread3->ConfigPath = "D:/config/config0768.xml";
    myCThread3->pid = 3;
    qDebug()<<"MyCThreadID:"<<myCThread->currentThreadId();
    //将线程分配到指定核心
    SetThreadAffinityMask(myCThread, 0x00000002);
    SetThreadAffinityMask(myCThread2, 0x00000004);
    SetThreadAffinityMask(myCThread3, 0x00000006);

    //进程信号与槽连接
    connect(myCThread,SIGNAL(start()),this,SLOT(run()));
    connect(myCThread2,SIGNAL(start()),this,SLOT(run()));
    connect(myCThread3,SIGNAL(start()),this,SLOT(run()));
    //进程触发信号与槽相连接
    connect(myCThread,SIGNAL(stateChanged(cameraThread::AcquisitionState)),this,SLOT(slotdealImage()));
    connect(myCThread,SIGNAL(DealStateChanged()),this,SLOT(ShowInformation()));
    connect(myCThread2,SIGNAL(stateChanged(cameraThread::AcquisitionState)),this,SLOT(slotdealImage()));
    connect(myCThread2,SIGNAL(DealStateChanged()),this,SLOT(ShowInformation()));
    connect(myCThread3,SIGNAL(stateChanged(cameraThread::AcquisitionState)),this,SLOT(slotdealImage()));
    connect(myCThread3,SIGNAL(DealStateChanged()),this,SLOT(ShowInformation()));
    connect(ui->checkBox_1, SIGNAL(stateChanged(int)), this, SLOT(Box1_StateChanged()));
    connect(ui->comboBox,SIGNAL(currentIndexChanged(QString)),this,SLOT(CameraShowChoose()));
    //connect(ui->VolumeSlider, SIGNAL(valueChanged(int)), this, SLOT(setLineEditValue(int)));
    //添加图片路径
    QString Path = ui->path->text();
    Path.replace("/","\\");
    std::string PATH = Path.toStdString();
    hv_Path = PATH.c_str();
    if(way_num == "fft")
    {
        ui->ways->setText("fft");
    }
    else if(way_num == "mura_blur")
    {
        ui->ways->setText("mura_blur");
    }
    else
    {
        ui->ways->setText("ERROR!");
    }

}

MainWindow::~MainWindow()
{
    //player->stop();
    delete ui;
}


void MainWindow::on_pushButton_readImage_clicked()
{
    myCThread->Running_State = ReadMode;
    hv_Index = 0;
    //Initializations初始化
    //关闭更新程序计数器、更新变量窗口、更新凸显窗口
    dev_update_off();
    //Image Acquisition 01: Code generated by Image Acquisition 01
    //遍历文件夹下文件
    ListFiles(hv_Path,
              (HTuple("files").Append("follow_links")), &hv_ImageFiles);
    //设置输入图片格式
    TupleRegexpSelect(hv_ImageFiles, (HTuple("\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$").Append("ignore_case")),
                      &hv_ImageFiles);

    //载入图片
    ReadImage(&ho_Image, HTuple(hv_ImageFiles[hv_Index]));
    //将原图转化为灰度图，第一个参数为原图
    Rgb1ToGray(ho_Image, &ho_Image);
    //获取图像长宽
    GetImageSize(ho_Image, &hv_Width, &hv_Height);
    if(InitCreatwindow == true)
    {
        //打开一个新的图像窗口  窗口大小、窗口背景、窗口语句柄
        //SetWindowAttr("background_color","black");
        /*Hlong winID =(Hlong) this->winId();*/
        if(winID == -1)
        {
            SetWindowAttr("background_color","black");
            winID =(Hlong) this->winId();
            OpenWindow(ui->label_2->y(),ui->label_2->x(),ui->label_2->width(),ui->label_2->height(),winID,"visible","",&hv_WindowHandle1);
            OpenWindow(ui->label_4->y(),ui->label_4->x(),ui->label_4->width(),ui->label_4->height(),winID,"visible","",&hv_WindowHandle);
        }

        Filter(hv_Width,hv_Height);
        InitCreatwindow = false;
    }

    //int cou = 0;
    QFuture<void> fut1 = QtConcurrent::run(this,&MainWindow::deal_process,0);
    //GMM_training();
    fut1.waitForFinished();

}


void MainWindow::slotdealImage()
{

    //time.start();

    hv_Index = 1;
    //判断是哪个相机采集到的信号
    if(myCThread->Dealcompleted == false)
    {
        hv_ImageFiles[hv_Index] = "mybitmap01";
        myCThread->Dealcompleted = true;
        //qDebug()<<1;
    }
    else if(myCThread2->Dealcompleted == false)
    {
        hv_ImageFiles[hv_Index] = "mybitmap02";
        myCThread2->Dealcompleted = true;
        //qDebug()<<2;
    }
    else
    {
        hv_ImageFiles[hv_Index] = "mybitmap03";
        myCThread3->Dealcompleted = true;
        //qDebug()<<3;
    }
    //初始化窗口
    if(InitCreatwindow == true)
    {

        //Initializations初始化
        //关闭更新程序计数器、更新变量窗口、更新凸显窗口
        dev_update_off();
        //载入图片
        ReadImage(&ho_Image, HTuple(hv_ImageFiles[hv_Index]));
        //hv_ImageFiles[hv_Index] = "mybitmap01";//hv_Path+(hv_Index.TupleString("02"));
        //获取图像长宽
        GetImageSize(ho_Image, &hv_Width, &hv_Height);

        //打开一个新的图像窗口  窗口大小、窗口背景、窗口语句柄
        if(winID == -1)
        {
            SetWindowAttr("background_color","black");
            winID =(Hlong) this->winId();
            OpenWindow(ui->label_2->y(),ui->label_2->x(),ui->label_2->width(),ui->label_2->height(),winID,"visible","",&hv_WindowHandle1);
            OpenWindow(ui->label_4->y(),ui->label_4->x(),ui->label_4->width(),ui->label_4->height(),winID,"visible","",&hv_WindowHandle);
        }
        InitCreatwindow = false;
        Filter(hv_Width,hv_Height);
        //myCThread->Dealcompleted = true;
    }
    ReadImage(&ho_Image, HTuple(hv_ImageFiles[hv_Index]));
    //在未开始处理时做图像的显示
    if(DealState == false)
    {
        if(CameraNum == 1)
        {
            if(hv_ImageFiles[hv_Index] == "mybitmap01")
            {
                DispObj(ho_Image,hv_WindowHandle1);              
            }
        }
        else if(CameraNum == 2)
        {
            if(hv_ImageFiles[hv_Index] == "mybitmap02")
            {
                DispObj(ho_Image,hv_WindowHandle1);               
            }
        }
        else if(CameraNum == 3)
        {
            if(hv_ImageFiles[hv_Index] == "mybitmap03")
            {
                DispObj(ho_Image,hv_WindowHandle1);
            }
        }
        else ;
    }
    //按下开始处理按钮，执行检测程序
    else if(DealState == true)
    {
        //图像处理部分使用线程的方式实现
        //deal_process(0);
        QFuture<void> fut1 = QtConcurrent::run(this,&MainWindow::deal_process,0);
        fut1.waitForFinished();
    }
    //qDebug()<<time.elapsed()<<"ms";
}
void MainWindow::setLineEditValue()
{
    int pos = ui->VolumeSlider->value();
    QString str = QString("%1").arg(pos);
    ui->voicevalue->setText(str);
}
//点击显示下一张
void MainWindow::on_pushButton_NextImage_clicked()
{
    HTuple end_val3 = (hv_ImageFiles.TupleLength())-1;
    HTuple step_val55 = 1;
    if(hv_Index < end_val3)
    {
        hv_Index=hv_Index+step_val55;
    }
    ReadImage(&ho_Image, HTuple(hv_ImageFiles[hv_Index]));
    int NumErrors = 0;//defects_laws(hv_Index);
    deal_process(NumErrors);

}
//点击显示上一幅图像
void MainWindow::on_pushButton_LastImage_clicked()
{
    HTuple step_val55 = 1;
    if(hv_Index > 1)
    {
        hv_Index=hv_Index-step_val55;
    }
    ReadImage(&ho_Image, HTuple(hv_ImageFiles[hv_Index]));
    int NumErrors = 0;//defects_laws(hv_Index);
    deal_process(NumErrors);
}
//读取设置的参数
void MainWindow::on_pushButton_MethodOK_clicked()
{
    //检测参数读取
    hv_Threshold = ui->threshold->text().toDouble();
    hv_Sigma1 = ui->sigma1->text().toDouble();
    hv_Sigma2 = ui->sigma2->text().toDouble();
    if(InitCreatwindow == false)
     Filter(hv_Width,hv_Height);
}

//路径选择
void MainWindow::on_pushButton_Path_clicked()
{
    QString s = QFileDialog::getExistingDirectory (
                this, "选择图片所在文件夹",
                "/",QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
    if (!s.isEmpty())
    {
        s.replace("/","\\");
        ui->path->setText(s);
    }
    QString Path = ui->path->text();
    std::string PATH = Path.toStdString();
    hv_Path = PATH.c_str();
}


void MainWindow::on_waychoose_clicked()
{
    way_num = ui->ways->text().toStdString();
}

void MainWindow::on_pushButton_Number_clicked()
{
    hv_Index = ui->Image_Number->text().toInt() - 2;
    if(hv_Index < -1)
        hv_Index = -1;
    else if(hv_Index >= (hv_ImageFiles.TupleLength())-2)
        hv_Index = (hv_ImageFiles.TupleLength())-2;
}

void MainWindow::Filter(HTuple Width,HTuple Height)
{
    //Optimize the fft speed for the specific image (根据指定图像大小进行fft速度最优化)
    OptimizeRftSpeed(Width, Height, "standard");
    //Construct a suitable filter by combining two gaussian
    //在频域上生成高斯滤波器
    //参数说明：生成的高斯滤波器(GaussFilter)
    //********空域中高斯在主方向上的标准差(Sigma)
    //********空域中高斯在于正交于主方向上的标准差(Sigma)
    //********滤波器主方向的角度(0.0)
    //********滤波器的规范('none')
    //********滤波器在频域的位置('rft')
    //********图片的大小(Width,Height)
    GenGaussFilter(&ho_GaussFilter1, hv_Sigma1, hv_Sigma1, 0.0, "none", "rft", hv_Width,
                   hv_Height);
    GenGaussFilter(&ho_GaussFilter2, hv_Sigma2, hv_Sigma2, 0.0, "none", "rft", hv_Width,
                   hv_Height);
    //两张图片相减(g=(g1-g2)*Mult+Add)
    SubImage(ho_GaussFilter1, ho_GaussFilter2, &ho_Filter, 1, 0);
    //生成GMM要检测区域-ROI
    GenRectangle1(&ho_Rectangle, 5, 5, (hv_Height/2)-5, (hv_Width/2)-5);
}
void MainWindow::deal_process(const int &NumErrors)
{
    //QMutexLocker locker(&mutex);
    time.start();
    //Process the images iteratively(对图像进行迭代运算)

    HObject ho_Domain;
    HTuple  hv_Mean1, hv_Deviation1;
    HTuple hv_HorProjection,hv_VertProjection;
    GetDomain (ho_Image, &ho_Domain);
    Intensity (ho_Domain, ho_Image, &hv_Mean1, &hv_Deviation1);
    GrayProjections(ho_Domain,ho_Image,"simple",&hv_HorProjection,&hv_VertProjection);
    //mean_image (Image1, Image, 3, 3)

    //Perform the convolution in the frequency domain
    //对计算一幅图像实部进行快速傅里叶变换
    //参数说明：输入的图片(Image)
    //*********傅里叶变换后输出的图片(ImageFFT)
    //*********变换方向('to_freq'或'from_freq')
    //*********变换因子的规范('none')
    //*********输出图片的数据类型('complex')
    //*********图片的宽(Width)
    RftGeneric(ho_Image, &ho_ImageFFT, "to_freq", "none", "complex", hv_Width);
    //对图片用一个滤波器在频域进行卷积运算
    //参数说明：输入图片(ImageFFT)
    //*********频域滤波器(Filter)
    //*********运算输出的结果(ImageConvol)
    ConvolFft(ho_ImageFFT, ho_Filter, &ho_ImageConvol);
    //对滤波后的图片进行傅里叶反变换
    RftGeneric(ho_ImageConvol, &ho_ImageFiltered, "from_freq", "n", "real", hv_Width);
    //用一个矩形掩膜计算像素点的灰度范围
    //参数说明：输入的图片(ImageFiltered)
    //*********输出的灰度范围图(ImageResult)
    //*********矩形掩膜大小(9,9)
    GrayRangeRect(ho_ImageFiltered, &ho_ImageResult, 9, 9);
    //利用全局阈值对图像进行分割
//    if(hv_Index > 55 && hv_Index < 61)
//        Threshold(ho_ImageResult, &ho_RegionDynThresh, (HTuple(5.55).Append(21.5)).TupleMax(),
//                  255);
//    else
        Threshold(ho_ImageResult, &ho_RegionDynThresh, (HTuple(5.55).Append(hv_Threshold)).TupleMax(),
                  255);
    //计算区域内的连通部分(输入的图片,得到的连通区域)
    Connection(ho_RegionDynThresh, &ho_ConnectedRegions);
    //根据特定的形态特征选择区域
    //参数说明：输入图片(ConnectedRegions)
    //*********满足条件的区域(SelectedRegions)
    //*********将要计算的形态特征('area')
    //*********独立特征间的连接关系('and')
    //*********特征最小限制(15)
    //*********特征最大限制(99999)
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", 30, 99999);
    //返回包含所有区域的集合(包含所有区域的待计算区域的图片，所有输入区域和)
    Union1(ho_SelectedRegions, &ho_RegionUnion);
    //用一个圆圈来封闭一个区域(将要被封闭的区域,被封闭的区域,圆半径)
    ClosingCircle(ho_RegionUnion, &ho_RegionClosing, 10);
    Connection(ho_RegionClosing, &ho_ConnectedRegions1);
    SelectShape(ho_ConnectedRegions1, &ho_SelectedRegions1, "area", "and", 30, 99999);
    //计算区域面积以及中心位置(待计算的区域,区域的面积,区域中心的行,区域中心的列)
    AreaCenter(ho_SelectedRegions1, &hv_Area, &hv_Row, &hv_Column);

    hv_Number = hv_Area.TupleLength();
    HTuple hv_Pos_Row, hv_Pos_Col;
    HTuple hv_size = 0;
    //不对传送带进行疵点检测
    if(hv_Mean1 < 35)
        hv_Number = 0;
    //qDebug() << hv_Mean1.ToString();
    if (0 != hv_Number)
    {

        //20180713二次判断，检测褶皱部分
         //图片放缩，缩短运行时间
         ZoomImageFactor(ho_Image, &ho_ImageZoomed, 0.5, 0.5, "constant");

         //Laws纹理滤波提取，组合五幅为纹理图像
         //‘el’模板Laws纹理滤波卷积
         TextureLaws(ho_ImageZoomed, &ho_ImageEL, "el", 5, 5);
         //'le'模板Laws纹理滤波卷积
         TextureLaws(ho_ImageZoomed, &ho_ImageLE, "le", 5, 5);
         //'es'模板Laws纹理滤波卷积
         TextureLaws(ho_ImageZoomed, &ho_ImageES, "es", 1, 5);
         //'se'模板Laws纹理滤波卷积
         TextureLaws(ho_ImageZoomed, &ho_ImageSE, "se", 1, 5);
         //'ee'模板Laws纹理滤波卷积
         TextureLaws(ho_ImageZoomed, &ho_ImageEE, "ee", 2, 5);
         //组合五幅图像为5通道图像
         Compose5(ho_ImageEL, ho_ImageLE, ho_ImageES, ho_ImageSE, ho_ImageEE, &ho_ImageLaws
             );
         //对图像进行光滑处理
         SmoothImage(ho_ImageLaws, &ho_IamgeTexture, "gauss", 5);
         //获得制定区域的图像
         ReduceDomain(ho_IamgeTexture, ho_Rectangle, &ho_ImageTextureReduced);
         //使用分类器对图像进行分类，获得同类的正确区域0.001
         ClassifyImageClassGmm(ho_ImageTextureReduced, &ho_Correct, hv_GMMHandle, 0.012);
         //*原来的ROI区域减去同类正确的区域得到瑕疵区域
         Difference(ho_Rectangle, ho_Correct, &ho_Errors);
         //通过开闭运算去掉无关紧要的部分区域
         OpeningCircle(ho_Errors, &ho_ErrorsOpening, 3);
         ClosingCircle(ho_ErrorsOpening, &ho_ErrorsCloseing, 10.5);
         //连通区域
         Connection(ho_ErrorsCloseing, &ho_ErrorsConnected);
         //区域选择面积大于300的
         SelectShape(ho_ErrorsConnected, &ho_FinalErrors, "area", "and", 9000, 999999999);

         //最后瑕疵区域计数
         CountObj(ho_FinalErrors, &hv_NumErrors);

        hv_Sum = 0;
        {
            HTuple end_val128 = hv_Number;
            HTuple step_val128 = 1;

            //合并坐标临近点的瑕疵
            for (hv_Index1=1; hv_Index1.Continue(end_val128, step_val128); hv_Index1 += step_val128)
            {


                hv_DEL = 0;
                //去除传送带干扰
                HTuple row = HTuple(hv_Row[hv_Index1-1]).TupleInt();
                if(hv_HorProjection[row] < 50
                        && hv_HorProjection[(row+1)<(hv_Height-1)?(row+1):(hv_Height-1)] < 50
                            && hv_HorProjection[(row-1)>0?(row-1):0]<50)
                {
                    hv_DEL = 1;
                }
                if (0 != (hv_Index1>1 && hv_DEL == 0))
                {
                    {
                        HTuple end_val131 = hv_Index1-1;
                        HTuple step_val131 = 1;
                        for (hv_Index2=1; hv_Index2.Continue(end_val131, step_val131); hv_Index2 += step_val131)
                        {
                            TupleAbs(HTuple(hv_Row[hv_Index1-1])-HTuple(hv_Row[hv_Index2-1]), &hv_Distance_Row);
                            TupleAbs(HTuple(hv_Column[hv_Index1-1])-HTuple(hv_Column[hv_Index2-1]),
                                    &hv_Distance_Col);
                            if ((hv_Distance_Row<50&&hv_Distance_Col<300)||(hv_Distance_Row<300&&hv_Distance_Col<50))
                            {
                                hv_DEL = 1;
                                break;
                            }
                        }
                    }
                }
                //去除部分误判
                if( NumErrors <= 0 )
                {
                    bool isDelate = true;
                    if(hv_Row[hv_Index1-1]<=7 || hv_Column[hv_Index1-1]<=7
                            ||hv_Row[hv_Index1-1]>hv_Height-7||hv_Column[hv_Index1-1] > hv_Width-7)
                    {
                        for(int i = 0 ; i < hv_Number ; i++)
                        {
                            if(i != (hv_Index1-1))
                            {
                                TupleAbs(HTuple(hv_Row[hv_Index1-1])-HTuple(hv_Row[i]), &hv_Distance_Row);
                                TupleAbs(HTuple(hv_Column[hv_Index1-1])-HTuple(hv_Column[i]),
                                        &hv_Distance_Col);
                                if ((hv_Distance_Row<50&&hv_Distance_Col<250)||(hv_Distance_Row<250&&hv_Distance_Col<50))
                                {
                                    isDelate = false;
                                    break;
                                }
                            }
                        }
                        if(isDelate == true)
                        {
                            hv_DEL = 1;
                        }
                    }
                    else
                    {
                        hv_size += HTuple(hv_Area[hv_Index1-1]);
                    }
                }
                else
                {
                    hv_size += HTuple(hv_Area[hv_Index1-1]);
                }


                HTuple hv_ROW,hv_COL,hv_Ind;
                if (0 != (hv_NumErrors>0))
                {
                  TupleInt(HTuple(hv_Row[hv_Index1-1])/2, &hv_ROW);
                  TupleInt(HTuple(hv_Column[hv_Index1-1])/2, &hv_COL);
                  GetRegionIndex(ho_FinalErrors, hv_ROW, hv_COL, &hv_Ind);
                  if (0 != (hv_Ind!=HTuple()))
                  {
                    hv_DEL = 1;
                  }
                }
                if (hv_DEL!=1)
                {
                    hv_Pos_Row[hv_Sum] = HTuple(hv_Row[hv_Index1-1]);
                    hv_Pos_Col[hv_Sum] = HTuple(hv_Column[hv_Index1-1]);
                    hv_Sum += 1;
                }
            }
        }
        //打印信息
        if(hv_Sum != 0)
        {
            GenCircleContourXld(&ho_ContCircle, hv_Pos_Row, hv_Pos_Col, HTuple(hv_Sum,40),
                                HTuple(hv_Sum,0), HTuple(hv_Sum,HTuple(360).TupleRad()), "positive", 1);
            hv_ResultMessage.Clear();
            hv_ResultMessage[0] = "Not OK";
            hv_ResultMessage.Append(hv_Sum+" defect(s) found");
            hv_Color.Clear();
            hv_Color[0] = "red";
            hv_Color[1] = "black";

            HString Sum = hv_Sum.TupleString("d");
            ui->sum->setText(QString(Sum));
            ui->result->setText("Not OK");
            //VoicePlay();
        }
        else
        {
            hv_ResultMessage = "OK";
            hv_Color = "forest green";
            ui->result->setText("OK");
            ui->sum->setText("0");
        }

    }
    else
    {
        hv_ResultMessage = "OK";
        hv_Color = "forest green";
        ui->result->setText("OK");
        ui->sum->setText("0");
    }
    //HString hv_Size = hv_size.TupleString("d");
    //ui->lineEdit_Area->setText(QString(hv_Size));
    HString hv_Imagenumber = (hv_Index+1).TupleString("d");
    ui->Image_Number->setText(QString(hv_Imagenumber));
    //在相机模式下处理结果的显示
    if(myCThread->Running_State == CameraMode)
    {
        if(CameraNum == 1)
        {
            if(hv_ImageFiles[hv_Index] == "mybitmap01")
            {
                myCThread->DealStateChanged();
            }
        }
        else if(CameraNum == 2)
        {
            if(hv_ImageFiles[hv_Index] == "mybitmap02")
            {
                myCThread2->DealStateChanged();
            }
        }
        else if(CameraNum == 3)
        {
            if(hv_ImageFiles[hv_Index] == "mybitmap03")
            {
                myCThread3->DealStateChanged();
            }
        }
        else ;
    }
    else
        myCThread->DealStateChanged();
    //qDebug()<<time.elapsed()<<"ms";

//    time.start();

}
//显示处理结果
void MainWindow::ShowInformation()
{

    DispObj(ho_Image,hv_WindowHandle1);
    //设置不依赖操作系统的字体
    HDevWindowStack::Push(hv_WindowHandle);
    set_display_font(hv_WindowHandle, 14, "mono", "true", "false");
    //定义区域填充模式
    if (HDevWindowStack::IsOpen())
    {
        SetDraw(HDevWindowStack::GetActive(),"margin");
        //设置区域轮廓的线宽
        SetLineWidth(HDevWindowStack::GetActive(),3);
        //设置输出颜色
        SetColor(HDevWindowStack::GetActive(),"red");
        //Display the results
        DispObj(ho_Image, HDevWindowStack::GetActive());
    }
    disp_message(hv_WindowHandle, hv_ResultMessage, "window", 12, 12, hv_Color, "true");
    if (hv_ResultMessage != "OK")
    {
        if (HDevWindowStack::IsOpen())
            DispObj(ho_ContCircle, HDevWindowStack::GetActive());
    }
    //在Camera模式下保存有错误的数据
    if(myCThread->Running_State == CameraMode)
    {
        if(hv_ResultMessage != "OK")
        {
            DumpWindow(hv_WindowHandle, "jpeg","img/image"+imgcount);
            WriteImage(ho_Image, "jpeg",0,"src/src"+imgcount);
            ++imgcount ;
        }
    }


}

void MainWindow::GMM_training(void)
{
    HTuple hv_J;
    //是否读取已存在的分类器
    hv_ReadPretrainedClassifier = 0;
    //是否保存分类器
    hv_SaveClassifier = 0;
    //*图像路径
    hv_HalconExamples = "C:\\Users\\Public\\Documents\\MVTec\\HALCON-12.0\\examples";
    //生成要检测区域-ROI
    GenRectangle1(&ho_Rectangle, 10, 10, (hv_Height/2)-11, (hv_Width/2)-11);
    //是否读取分类器
    if (0 != hv_ReadPretrainedClassifier)
    {
        //显示图像
        if (HDevWindowStack::IsOpen())
            DispObj(ho_Image, HDevWindowStack::GetActive());
        //显示从硬盘读取分类器
        disp_message(hv_WindowHandle, "Reading classifier from disk...", "window", 10,
                     10, "black", "true");
        //从硬盘读取分类器
        ReadClassGmm(hv_HalconExamples+"/hdevelop/Segmentation/Classification/novelty_detection.gmm",
                     &hv_GMMHandle);
        //等待
        //WaitSeconds(1.5);
    }
    else
    {
        //创建高斯混合模型* 训练样本基于五幅图像s，中心数1~5
        CreateClassGmm(5, 1, (HTuple(1).Append(5)), "spherical", "normalization", 5,
                       42, &hv_GMMHandle);
        //循环读取五幅图像，提取特征添加到GMM模型中训练
        for (hv_J=1; hv_J<=5; hv_J+=1)
        {
            //*读取图片
            ReadImage(&ho_Image, HTuple(hv_ImageFiles[hv_J - 1]));
            //将原图转化为灰度图，第一个参数为原图
            Rgb1ToGray(ho_Image, &ho_Image);
            //直方图均衡化
            //equ_histo_image (srcImage, Image)
            //*图片放缩，缩短运行时间
            ZoomImageFactor(ho_Image, &ho_ImageZoomed, 0.5, 0.5, "constant");
            HDevWindowStack::Push(hv_WindowHandle1);
            //显示缩小后的图像
            if (HDevWindowStack::IsOpen())
                DispObj(ho_ImageZoomed, HDevWindowStack::GetActive());
            //显示信息增加训练样本
            /*disp_message(hv_WindowHandle1, "Adding trianing sample...", "window", 10, 10,
            "black", "true");*/
            //Laws纹理滤波提取，组合五幅为纹理图像
            //‘el’模板Laws纹理滤波卷积
            TextureLaws(ho_ImageZoomed, &ho_ImageEL, "el", 5, 5);
            //'le'模板Laws纹理滤波卷积
            TextureLaws(ho_ImageZoomed, &ho_ImageLE, "le", 5, 5);
            //'es'模板Laws纹理滤波卷积
            TextureLaws(ho_ImageZoomed, &ho_ImageES, "es", 1, 5);
            //'se'模板Laws纹理滤波卷积
            TextureLaws(ho_ImageZoomed, &ho_ImageSE, "se", 1, 5);
            //'ee'模板Laws纹理滤波卷积
            TextureLaws(ho_ImageZoomed, &ho_ImageEE, "ee", 2, 5);
            //组合五幅图像为5通道图像
            Compose5(ho_ImageEL, ho_ImageLE, ho_ImageES, ho_ImageSE, ho_ImageEE, &ho_ImageLaws
                     );
            //对图像进行光滑处理
            SmoothImage(ho_ImageLaws, &ho_IamgeTexture, "gauss", 5);
            //样本添加到分类器
            AddSamplesImageClassGmm(ho_IamgeTexture, ho_Rectangle, hv_GMMHandle, 2.0);
        }
        HDevWindowStack::Push(hv_WindowHandle1);
        //显示原图像
        if (HDevWindowStack::IsOpen())
            DispObj(ho_Image, HDevWindowStack::GetActive());
        //显示信息正在训练GMM
        disp_message(hv_WindowHandle1, "GMM training...", "window", 10, 10, "black", "true");
        //训练高斯混合分类器
        TrainClassGmm(hv_GMMHandle, 100, 0.001, "training", 1e-4, &hv_Centers, &hv_Iter);
        //是否保存分类器
        if (0 != hv_SaveClassifier)
        {
            WriteClassGmm(hv_GMMHandle, hv_HalconExamples+"/hdevelop/Segmentation/Classification/novelty_detection.gmm");
        }
    }
}


HTuple MainWindow::defects_laws(HTuple hv_J)
{
    //读取图像
    ReadImage(&ho_Image, HTuple(hv_ImageFiles[hv_J]));
    //将原图转化为灰度图，第一个参数为原图
    Rgb1ToGray(ho_Image, &ho_Image);
    //直方图均衡化
    //equ_histo_image (srcImage, Image)
    //图片放缩，缩短运行时间
    ZoomImageFactor(ho_Image, &ho_ImageZoomed, 0.5, 0.5, "constant");
    //显示缩放后的图像
    //    if (HDevWindowStack::IsOpen())
    //        DispObj(ho_ImageZoomed, HDevWindowStack::GetActive());
    //Laws纹理滤波提取，组合五幅为纹理图像
    //‘el’模板Laws纹理滤波卷积
    TextureLaws(ho_ImageZoomed, &ho_ImageEL, "el", 5, 5);
    //'le'模板Laws纹理滤波卷积
    TextureLaws(ho_ImageZoomed, &ho_ImageLE, "le", 5, 5);
    //'es'模板Laws纹理滤波卷积
    TextureLaws(ho_ImageZoomed, &ho_ImageES, "es", 1, 5);
    //'se'模板Laws纹理滤波卷积
    TextureLaws(ho_ImageZoomed, &ho_ImageSE, "se", 1, 5);
    //'ee'模板Laws纹理滤波卷积
    TextureLaws(ho_ImageZoomed, &ho_ImageEE, "ee", 2, 5);
    //组合五幅图像为5通道图像
    Compose5(ho_ImageEL, ho_ImageLE, ho_ImageES, ho_ImageSE, ho_ImageEE, &ho_ImageLaws);
    //对图像进行光滑处理
    SmoothImage(ho_ImageLaws, &ho_IamgeTexture, "gauss", 5);
    //获得制定区域的图像
    ReduceDomain(ho_IamgeTexture, ho_Rectangle, &ho_ImageTextureReduced);
    //使用分类器对图像进行分类，获得同类的正确区域
    ClassifyImageClassGmm(ho_ImageTextureReduced, &ho_Correct, hv_GMMHandle, 0.001);
    //*原来的ROI区域减去同类正确的区域得到瑕疵区域
    Difference(ho_Rectangle, ho_Correct, &ho_Errors);
    //通过开闭运算去掉无关紧要的部分区域
    OpeningCircle(ho_Errors, &ho_ErrorsOpening, 3.5);
    ClosingCircle(ho_ErrorsOpening, &ho_ErrorsCloseing, 10.5);
    //连通区域
    Connection(ho_ErrorsCloseing, &ho_ErrorsConnected);
    //区域选择面积大于300的
    SelectShape(ho_ErrorsConnected, &ho_FinalErrors, "area", "and", 300, 1000000);
    //最后瑕疵区域计数
    CountObj(ho_FinalErrors, &hv_NumErrors);

    return hv_NumErrors;
    //ClearMutex(gStartMutex);
}


void MainWindow::VoicePlay()
{
    int Volume;
    player = new QMediaPlayer;
    connect(player, SIGNAL(positionChanged(qint64)), this, SLOT(positionChanged(qint64)));
    QString runPath = QCoreApplication::applicationDirPath();
    player->setMedia(QUrl::fromLocalFile(runPath+"\\mp3\\warning.mp3"));
    Volume = ui->VolumeSlider->value();
    player->setVolume(Volume);
    player->play();
}




void MainWindow::on_pushButton_clicked()
{
    myCThread->Running_State = CameraMode;
    myCThread -> start();
    WaitSeconds(0.3);
    myCThread2->Running_State = CameraMode;
    myCThread2 -> start();
    WaitSeconds(0.2);
    myCThread3->Running_State = CameraMode;
    myCThread3 -> start();
    //InitCreatwindow = true;
}

void MainWindow::on_pushButton_startorstop_clicked()
{
    DealState = 1 - DealState;
    if(DealState == true)
        ui->pushButton_startorstop->setText("StopDeal");
    else
    {
        ui->pushButton_startorstop->setText("StartDeal");
    }
}
void MainWindow::CameraShowChoose()
{
    CameraNum = 1 + ui->comboBox->currentIndex();
}
void MainWindow::Box1_StateChanged()
{


}
void MainWindow::Box2_StateChanged()
{


}
void MainWindow::Box3_StateChanged()
{


}
void MainWindow::Box4_StateChanged()
{


}
void MainWindow::Box5_StateChanged()
{


}
